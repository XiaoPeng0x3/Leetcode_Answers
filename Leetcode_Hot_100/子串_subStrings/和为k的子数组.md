# 和为k的子数组

## 描述

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。
>
> 子数组是数组中元素的连续非空序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,1], k = 2
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3], k = 3
> 输出：2
> ```



## 思路

### 暴力解法

意思就是去找子数组的和为`target`的数组个数，首先暴力做法是很容易想到的，就是去遍历子数组，然后看一看子数组的和即可

### 暴力优化

在这里用到的优化思路就是**哈希表+前缀和**。首先，对于一个子数组来说，例如，从`nums[i]到nums[j]`,我们可以记录一个前缀和数组。这里，我们可以来模拟一下

```txt
数组元素： 4 1 2 3  0  6  2  4
计算前缀和
前缀和    4 5 7 10 10 16 18 22

找一下子数组和为6的子数组数目
```

可以看到，在一个区间内，因为`prevSum[i-1] + nums[i] = prevSum[i]`,前面这个是前缀和的计算公式，那么，如果我们想要寻找和为`k`的子数组，我们就可以转过来去寻找是否存在`prevSum[i] - k`的前缀是否存在，如果存在，那么就可以说明`prevSum[j] + k = prevSum[i]`,这里假设是某个前缀和`prevSUm[j]`存在，那么从**`j+1的位置到i的和就是我们的k`**。那么，我们就可以通过记录这个前缀 和出现的次数来统计和为k的子数组的出现次数。和两数之和有点像。



## 暴力解法

```go
func subarraySum(nums []int, k int) int {
    n := len(nums)
    ans := 0
    for s := 0; s < n; s++{
        sum := 0
        for end := s; end < n; end++{
            sum += nums[end]
            if sum == k{
                ans++
            }
        }
    }
    return ans
}
```



## 优化解法

```go
func subarraySum(nums []int, k int) int {
    ans := 0
    // 创建好哈希表
    cnt := map[int]int{0:1} //前缀和为0的出现次数是1次
    //计算好一个前缀和数组
    perSum := 0
    for _, val := range nums{
        perSum += val
        // 从哈希表里面查询perSum[i]-k是否存在
        if a, ok := cnt[perSum - k];ok{
            //存在，那么就加上这个前缀出现的次数即可
            ans += a
        }
        //在这里添加前缀的出现次数
        cnt[perSum]++
    }
    return ans
}
```

