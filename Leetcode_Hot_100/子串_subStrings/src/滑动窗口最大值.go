func maxSlidingWindow(nums []int, k int) []int {
    // 创建好单调队列
    q := []int{}
    
    // 创建好ans数组返回
    n := len(nums)
    ans := make([]int, 0, n - k + 1)
    
    // 确定好单调队列的思路
    
    // 开始入队
    for i, num := range nums{
        // 开始入队
        // 队列不为空，并且队列的末端元素小于我们按照索引得到的 num
        for len(q) > 0 && nums[q[len(q) - 1]] <= num{
            // 这时候就得num来扮演心狠手辣的角色了
            // 得把它前面小的数全部删掉
            q = q[:len(q) - 1] // 如果删掉之后还是比num小，那么还是会继续执行循环
        }
        // 执行到这里，那么这个元素找到自己的位置了
        // 这个元素已经把前面比他小的所有数全部删除掉了，只剩下它的大哥们了
        q = append(q, i) //添加进去
        
        // 考虑出队
        // 历史的车轮滚滚向前，留给每个人出场的机会都是相同的，每个人都有自己的出场时机
        // 因此，有退才有进，这个时候，我们就得想一想这个“大哥”什么时候退下
        // 如果当前的时期i已经超过了q[0]，q[0]是大哥的下标索引，那么大哥就不是大哥了
        if i - q[0] >= k{
            q = q[1:]
        }
        
        // 什么时候添加答案呢
        // 首先在遍历的索引i小于k的时候，比如说k = 2, 那么实际上在i = 0的时候是没有要添加的答案的，直到i = 1的时候才添加了一次答案
        if i > = k - 1{
            // q[0]存储的是大哥的索引下标
            ans = append(ans, nums[q[0]])
        }
    }
    return ans
    
}