# 滑动窗口最大值

## 描述

[TOC]

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回 *滑动窗口中的最大值* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1], k = 1
> 输出：[1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`
> - `1 <= k <= nums.length`



## 思路

这道题目的主要思路就是滑动窗口和单调队列。其实主要精髓就是**单调队列**。单调队列的意思就是还是队列的数据结构，还是保持先进先出的顺序。只不过数据会发生改变，这里还是引用一个评论区的一个评论吧，说的非常好。单调队列真是一种让人感到五味杂陈的数据结构，它的维护过程更是如此.....就拿此题来说，队头最大，往队尾方向单调......有机会站在队头的老大永远心狠手辣，当它从队尾杀进去的时候，如果它发现这里面没一个够自己打的，它会毫无人性地屠城，把原先队里的人头全部丢出去，转身建立起自己的政权，野心勃勃地准备开创一个新的王朝.....这时候，它的人格竟发生了一百八十度大反转，它变成了一位胸怀宽广的慈父！它热情地请那些新来的“小个子”们入住自己的王国......然而，这些小个子似乎天性都是一样的——嫉妒心强，倘若见到比自己还小的居然更早入住王国，它们会心狠手辣地找一个夜晚把它们通通干掉，好让自己享受更大的“蛋糕”；当然，遇到比自己强大的，它们也没辙，乖乖夹起尾巴做人。像这样的暗杀事件每天都在上演，虽然王国里日益笼罩上白色恐怖，但是好在没有后来者强大到足以干翻国王，江山还算能稳住。直到有一天，闯进来了一位真正厉害的角色，就像当年打江山的国王一样，手段狠辣，野心膨胀，于是又是大屠城......历史总是轮回的。

意思就是说，我们是向这个队列里面添加数据，如果这个数很大(心狠手辣)，那么它会将前面所有小的数全部清除，让它自己坐在王位。如果遇到比他小的数，那么它就会把比他小的数放在后面(此时又是一位仁慈的君王)。直到遇到比它还大的数把它给杀掉。因此，只需要在一个固定长度的滑动窗口内，我们维护一个单调队列，**单调队列**的队首元素就是最大值，每次只需要维护队首元素即可。



## 代码

这里使用单调队列来存储**最大元素的索引**。要记住这类题目的思路即可，什么时候入队、出队、添加元素，要牢牢记住套路

```go
func maxSlidingWindow(nums []int, k int) []int {
    // 创建好单调队列
    q := []int{}
    
    // 创建好ans数组返回
    n := len(nums)
    ans := make([]int, 0, n - k + 1)
    
    // 确定好单调队列的思路
    
    // 开始入队
    for i, num := range nums{
        // 开始入队
        // 队列不为空，并且队列的末端元素小于我们按照索引得到的 num
        for len(q) > 0 && nums[q[len(q) - 1]] <= num{
            // 这时候就得num来扮演心狠手辣的角色了
            // 得把它前面小的数全部删掉
            q = q[:len(q) - 1] // 如果删掉之后还是比num小，那么还是会继续执行循环
        }
        // 执行到这里，那么这个元素找到自己的位置了
        // 这个元素已经把前面比他小的所有数全部删除掉了，只剩下它的大哥们了
        q = append(q, i) //添加进去
        
        // 考虑出队
        // 历史的车轮滚滚向前，留给每个人出场的机会都是相同的，每个人都有自己的出场时机
        // 因此，有退才有进，这个时候，我们就得想一想这个“大哥”什么时候退下
        // 如果当前的时期i已经超过了q[0]，q[0]是大哥的下标索引，那么大哥就不是大哥了
        if i - q[0] >= k{
            q = q[1:]
        }
        
        // 什么时候添加答案呢
        // 首先在遍历的索引i小于k的时候，比如说k = 2, 那么实际上在i = 0的时候是没有要添加的答案的，直到i = 1的时候才添加了一次答案
        if i > = k - 1{
            // q[0]存储的是大哥的索引下标
            ans = append(ans, nums[q[0]])
        }
    }
    return ans
    
}
```



