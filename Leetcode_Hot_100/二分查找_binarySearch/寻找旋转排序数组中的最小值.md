# 寻找排序数组中的最小值

[TOC]

## 描述

> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
>
> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
> - 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
>
> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
>
> 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,4,5,1,2]
> 输出：1
> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [4,5,6,7,0,1,2]
> 输出：0
> 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [11,13,15,17]
> 输出：11
> 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
> ```
>
>  
>
> **提示：**
>
> - `n == nums.length`
> - `1 <= n <= 5000`
> - `-5000 <= nums[i] <= 5000`
> - `nums` 中的所有整数 **互不相同**
> - `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转



题目的意思还是去在一个旋转排序数组里面做文章，但是还是要求`O(logn)`的时间复杂度的算法，那么就只能使用二分法去找答案了。



## 思路

这次的思路是让`nums[mid]`跟左右两边比较位置了，只能说很巧妙。任意一个旋转后的数组都可以画成

```txt
   .  (最大值)       
  .         
 .      
    
       .
      .
     .
    . (最小值) 
```

这样的形式，从图上我们可以很清晰的看到最小值在哪里。这道题目的思路就是去比较最小值和`nums[mid]`的关系即可。它们两者之间的关系无非就两种情况，第一种情况就是`nums[mid] < min_val`,从图上的关系上来看就是在最小值的左边，第二种关系就是`nums[mid] > min_val`,在这种情况下，最小值就是在它的左侧。

那么，最重要的想法就还是**去寻找一个有序的区间**，怎么寻找呢，题解实际上提供了一种办法，就是让`nums[mid] cmp nums[n - 1]`,让这个值去跟数组最右边的值去比较。实际上，最右边的那个数一定是某个区间的结束位置，所以，如果这个`nums[mid] < nums[n - 1]`,那么`nums[mid]`实际上是在一个连续的区间上，而且还是最小值的区间上，那么要找到最小值只需要向左边寻找即可

```go
r = mid - 1
```

同理，如果是`nums[mid] > nums[n - 1]`,那么就是在比较大的值的区间里面，这个时候就需要向右查找，直到找到我们的最小值。



## 代码

注意一些细节！

```go
func findMin(nums []int) int {
    n := len(nums)
    l, r := 0, n - 1
    for l <= r {
        mid := l + (r - l) / 2
        if nums[mid] < nums[n -1] {
            r = mid - 1
        } else {
            l = mid + 1
        }
    }
    return nums[l]
}
```

