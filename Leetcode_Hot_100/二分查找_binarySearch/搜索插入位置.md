# 搜索插入位置

## 描述

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```
>
> **示例 3:**
>
> ```
> 输入: nums = [1,3,5,6], target = 7
> 输出: 4
> ```
>
>  
>
> **提示:**
>
> - `1 <= nums.length <= 104`
> - `-104 <= nums[i] <= 104`
> - `nums` 为 **无重复元素** 的 **升序** 排列数组
> - `-104 <= target <= 104`



## 思路

由于是在已经排好序的数组里面寻找元素，并且还需要算法的时间复杂度是`O(logn)`，这道题目很自然的让我们想到了**二分法**的操作。



## 代码

值得注意的是，当我们找不到元素的时候，要想一想应该在什么位置插入这个元素。你可以简单的画个图来想一想这个元素应该在哪里插入。比如说这里有一个列表是 `[1,3]`，我们要插入2。先写一个代码看看：

```go
func searchInsert(nums []int, target int) int {
    // 假设target在我们的列表里面，那么就是最普通的二分法
    l, r := 0, len(nums) - 1
    x, mid := 0, 0
    for l <= r{
        mid = l + (r - l) / 2
        x = nums[mid]
        if x == target {
            return mid
        } else if x < target {
            l = mid + 1
        } else {
            r = mid - 1
        }
    }
    // 如果找不到，那么我们应该返回哪个下标索引呢
    // 可以想一下，退出循环的条件就是 l > r,更确切来说，是 l = r + 1
    // 现在想一下，当 l == r 时，如果x 比 target要小，那么执行的就是 l = mid + 1
    // 反之，则会执行 r = mid - 1
    // 可以发现，最后执行的那次循环的x就是要排在我们target的前面的那个数
    // 而最后 l执行了++操作，所以最后返回l即可
    // 也可以返回 r + 1
    return l
}
```

