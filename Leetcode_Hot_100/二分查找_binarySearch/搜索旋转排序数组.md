# 搜索旋转排序数组

## 描述

> 整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。
>
> 在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。
>
> 给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 3
> 输出：-1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1], target = 0
> 输出：-1
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 5000`
> - `-104 <= nums[i] <= 104`
> - `nums` 中的每个值都 **独一无二**
> - 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
> - `-104 <= target <= 104`



## 思路

首先肯定是利用二分的方法去做。因为数组只旋转了一次，那么随机在数组里面砍一刀把数组一分为二，那么**总是有一半数组是有序的**，在有序数组的那一部分，我们就可以使用二分法；如果`target`是在无序的数组里面，那么我们就得想办法去收缩数组。关键是怎么判断那一部分是有序数组呢？

- 对于升序的数组来说，一定有`nums[mid] > nums[l] && nums[mid] < nums[r]`成立，但是在旋转数组过后却不一定了。在这里举一个例子
  ```txt
  数组是：
  [5,6,7,1,2,3,4]
  长度为7，nums[mid]为1
  假设我们要寻找的target 是3
  ```

  因为`nums[mid] = 1`,如果说`nums[mid] < nums[r]`,那么从`mid 到 r`的那个区间里面就是有序的，如果说`nums[mid] < target`,那么我们直接就可以在这个区间里面寻找。如果说`nums[mid] > target`,那么就得去左边寻找。

- 这样，我们就确定好了思路。先判断根据`mid`一分为二的两个区间哪个区间是有序的，如果说左边是有序的话并且那个数确实是在左区间那里，我们直接在左区间使用二分查找，反之则去右区间。

- 同理，如果右边是有序的话并且那个数确实是在右区间的话，那么就去右区间寻找；反之就去左区间寻找



## 代码

确定好思路和区间位置

```go
func search(nums []int, target int) int {
    l, r := 0, len(nums) - 1
    x, mid := 0, 0
    for l <= r {
        mid = l + (r - l) / 2
        x = nums[mid]
        if x == target {
            return mid
        }else if x < nums[r] {
            // 右边有序

            // 看一看target在哪个区间里面
            // 确实是在右区间
            if x < target && target <= nums[r]{
                l = mid + 1
            } else {
                r = mid - 1
            }
        } else {
            // 确实是在左区间
            if x > target && nums[l] <= target {
                r = mid - 1 //去左边寻找
            } else {
                l = mid + 1
            }
        }
    }
    return -1
}
```

