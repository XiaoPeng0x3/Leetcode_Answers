# 三数之和

## 题目描述

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请
>
> 你返回所有和为 `0` 且不重复的三元组。
>
> **注意：**答案中不可以包含重复的三元组。
>
>  
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> 解释：
> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
> 注意，输出的顺序和三元组的顺序并不重要。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,1]
> 输出：[]
> 解释：唯一可能的三元组和不为 0 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [0,0,0]
> 输出：[[0,0,0]]
> 解释：唯一可能的三元组和为 0。
> ```

意思就是说在给定一个数组之后，你需要去数组里面找到三个数，就拿第一个示例来举例的话，对于一个数组来说，`nums = [-1,0,1,2,-1,-4]`，可以组成的一个三元组就是[-1,-1,2]。

## 思路

### 直接暴力搜索

首先就是可以去暴力搜索，直观上，在第一次搜索的时候，会搜索到[-1,0,1],可以看到，后面也有一个-1，也就是说当去使用暴力搜索的时候，会搜索重复([-1,0,1],[0,1,-1]这两个实际上是一个元组),并且复杂度还很高

### 排序+暴力搜索

排序过后，我们就可以有办法去判断去重了。举个例子，对于`nums = [-1,0,1,2,-1,-4]`来说，排序过后元素是[-4,-1,-1,0,1,2]，那么对于相同的数来说，在数组内部的排序一定是紧紧相邻的，这时，同一个数直接跳过即可，不需要参与计算。但是，暴力搜索的时间复杂度还是很高，因为在此过程中我们还是没有利用好排序元素这个特性。

### 双指针

在排序过后，我们还是得枚举三元组，也就是说对于一个元素`nums[i]`来说，如果`x = nums[i] + nums[i + 1] + nums[j]`,j是最后一个元素，x如果大于0，说明**最后一个nuns[j]一定可以排除掉**，反之如果小于0，那么说明`nums[i+1]`也可以直接排除，只有比这个`nums[i+1]`还要大才有可能使结果为正。思路很好！

```go
func threeSum(nums []int) [][]int {
    //先准备好答案
    ans := make([][]int, 0)
    n := len(nums)
    //对数组进行排序
    sort.Ints(nums)
    for i := 0; i < n - 2; i++ {
        //先去重nums[i],和上一个数作比较
        if i > 0 && nums[i] == nums[i - 1] {
            continue
        }
        // 否则则开始寻找
        x := nums[i]
        j := i + 1
        k := n - 1
        // 定i不动，移动j和k
        for j < k {
            if x + nums[j] + nums[k] < 0{
                j++
            } else if x + nums[j] + nums[k] > 0{
                k--
            }else{
                // 找到答案了
                ans = append(ans,[]int{x, nums[j], nums[k]})
                //然后开始对这两个nums[j]和nums[k]去重
                j++
                for j < k && nums[j] == nums[j - 1]{
                        j++
                }
                k--
                for j < k && nums[k] == nums[k + 1]{
                        k--
                }
            }

        }
        
    }
    return ans
}
```

需要注意的是，去重移动的条件是**这个数与前面的数相等并且不越界**

