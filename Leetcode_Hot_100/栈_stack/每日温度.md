# 每日温度

## 描述

> 给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
>
>  
>
> **示例 1:**
>
> ```
> 输入: temperatures = [73,74,75,71,69,72,76,73]
> 输出: [1,1,4,2,1,1,0,0]
> ```
>
> **示例 2:**
>
> ```
> 输入: temperatures = [30,40,50,60]
> 输出: [1,1,1,0]
> ```
>
> **示例 3:**
>
> ```
> 输入: temperatures = [30,60,90]
> 输出: [1,1,0]
> ```
>
>  
>
> **提示：**
>
> - `1 <= temperatures.length <= 105`
> - `30 <= temperatures[i] <= 100`



实际上的意思就是**寻找数组里面每个元素最右边比它大的数的下标**



## 思路

这里主要使用的就是单调栈算法，具体来说，就是维护一个单调递增的栈，根据栈里面结果的弹出来判断一下。

### 从右向左遍历

这里要明确一点，从栈底到栈顶是按照升序排序的，因为是从右向左的，对于一个数来说，如果它不必栈顶元素大，那么它右边第一次出现的最大值就是栈顶坐标出现的位置。反之，如果说当前元素比栈顶大，那么栈顶就不会是右边第一个比它大的数。**以删除为主，不可以处理重复的元素**

#### 代码

还是要注意一些细节

```go
func dailyTemperatures(temperatures []int) []int {
    n := len(temperatures) //获得数组长度
    ans := make([]int, n)
    
    st := []int{}
    
    // 从右向左遍历
    for i := n - 1; i >= 0; i-- {
        // 栈不为空，并且栈顶元素小于遇到的元素是，要弹出，直到栈顶位置比遇到的那个元素大为止
        for len(st) > 0 && temperatures[i] >= temperatures[st[len(st) - 1]] {
            // 开始弹出栈元素
            st = st[ :len(st) - 1]
        }
        // 弹出后就是遇到了比自己大的那个数
        // 而且比自己大的那个数还是栈顶
        if len(st) > 0 {
            ans[i] = st[len(st) - 1] - i
        }
        // 添加新的元素入栈
        st = append(st, i)
    }
    return ans
    
}
```



### 从左向右遍历

还是从左向右遍历比较好，适合的情况比较多，不过从右向左的思路还是很自然的。

从左向右来说，还是维护一个单调栈