# 最长连续序列

## 题目描述

这个题目的意思就是给你一个数组，数组里面有一些连续的数字，你需要在这个数组里面找到最长的连续数字的长度，官方描述是

>**示例 1：**
>
>```
>输入：nums = [100,4,200,1,3,2]
>输出：4
>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
>```
>
>**示例 2：**
>
>```
>输入：nums = [0,3,7,2,5,8,4,6,0,1]
>输出：9
>```

## 思路

1. 显然，排序是最简单的方法了，直接进行排序，然后直接依次比较，每次都去记录一下最大的序列长度，然后下一次循环的起点就从断掉那里开始，然后继续向后面进行循环即可。
   但是，这个办法显然是不满足`O(n)`的要求，因此，最好的方法还是去使用哈希表了

2. 这里面使用哈希表去记录，因为哈希表非常适合去查询，同时，这个算法的核心思路就是去**找端点**，什么意思呢，因为是连续序列，对于一个端点，比如说`x = 1`,那么我们就只需要挨个从哈希表里面查询一边即可，边查询边记录，例如一个哈希表里面的键可能是
   ```go
   list := [1,2,3,4,8,9,10,12,13,14]
   ```

   这是随便写的一个例子，显然，我们只要找到`1`,`8`,`12`,那么我们就可以看一下以这些**端点为起始点的序列**哪一个是最长的即可。问题就在于，怎么寻找端点

   - 排序。直接排序，很容易找到端点，但是时间复杂度就不是`O(n)`了
   - 随机选择。这里就选择哈希表里面的第一个元素作为起点，**然后就是我们的核心思路，对于一个存在于哈希表里面的一个数`x`来说，我们只需要去看一下`x-1`是否存在即可**。如果`x-1`存在，说明这个数`x`一定不是起点，如果不存在，那么`x`就可以作为一个起点

## 代码实现

很好，我们已经有了思路，下面就是代码实现

```go
func longestConsecutive(nums []int) int {
    // 先把元素插到哈希表里面
    mp := map[int]bool{}
    for _, val := range nums {
        mp[val] = true
    }
    ans := 0
    // 插好了，现在就可以寻找了
    for k, _ := range mp {
        // 为false说明k是端点
        if !mp[k - 1] {
            cnt := k
            for mp[cnt] {
                cnt++
            }
            // 下面我们可以说一下， cnt返回的是最后端点+1的值，k是起点，正好相减即可
            ans = max(ans, cnt - k)
        }
    } 
    return ans
}
```

