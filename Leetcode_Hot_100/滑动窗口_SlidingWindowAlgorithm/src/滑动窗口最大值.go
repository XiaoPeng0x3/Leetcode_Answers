func maxSlidingWindow(nums []int, k int) []int {
    // 初始化答案数组
    // 这个数组的大小最多就是 len(nums) - k，后面的元素个数无法构成窗口
    ans := make([]int, 0, len(nums) - k + 1)
    // 创建好我们的双端队列
    // 在双端队列里面存放的是我们的下标索引
    q := []int{}
    
    for i, val := range nums{
        //入队
        // 单调队列的维护
        for len(q) > 0 && nums[q[len(q) - 1]] <= val{
            // 那么，之前在这个队列里面的数是不配在 val这个数前面的，我们要把前面这个数给删掉
            q = q[: len(q) - 1]
        }
        // 把元素下标添加进来
        q = append(q, i)
        
        // 出队
        // 出队的条件是滑动窗口长度过大，队首元素应该出队
        // 也就是说，队首元素已经不是它在的所有窗口的队首了
        // 就像是 1 1 5 3 4,可以看到，假设长度k为2的话，那么窗口为 [1 1],[1 5] [5 3],这个时候,5就会被移走，也就是当前索引比队首元素下标大k的时候，队首会被移走
        if i - q[0] >= k{
            q = q[1:]
        }
        
        // 添加答案
        //什么时候添加答案呢，可以看到
        // [1  3  -1] -3  5  3  6  7       3
 		// 1 [3  -1  -3] 5  3  6  7       3
 		// 1  3 [-1  -3  5] 3  6  7       5
        
        // 实际上，这里的长度是k,那么在i小于k-1(下标要-1)时，实际上是没有答案的，不构成滑动窗口的长度
        // 然后，在构成滑动窗口后，每次都会添加进来一个最大值，一直添加到 len(nums) - k
        if i >= k - 1{
            // 添加队首元素
            ans = append(ans, nums[q[0]])
        }
        
    }
    return ans
    
}