# 滑动窗口最大值

## 描述

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回 *滑动窗口中的最大值* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1], k = 1
> 输出：[1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`
> - `1 <= k <= nums.length`



题目的描述还是很清晰的，来说一下思路。



## 思路

这里用到的方法就是**单调队列**，对于这道题目来说，我们每次都去维护一个队列，但是这个队列不是普通的队列。当元素入队的时候，我们就要想办法去维护一下最大值。

我们分开存储，首先是把所有元素的下标存储在一个双端队列里面，然后再在这个双端队列里面进行操作。对于任意的一个序列，我们把最大的元素一直维护在队首那里，如果后面进来队列的元素大于队首元素，那么就把前面所有的元素清空。

总的来说，思路就是：

- 入队
  - 什么时候入队
  - 入队要进行哪些判断和操作
- 出队
  - 什么时候出队
  - 出队要维护哪些结构
- 添加答案
  - 满足什么条件，我们就要添加答案呢？



## 代码实现

单调队列

```go
func maxSlidingWindow(nums []int, k int) []int {
    // 初始化答案数组
    // 这个数组的大小最多就是 len(nums) - k，后面的元素个数无法构成窗口
    ans := make([]int, 0, len(nums) - k + 1)
    // 创建好我们的双端队列
    // 在双端队列里面存放的是我们的下标索引
    q := []int{}
    
    for i, val := range nums{
        //入队
        // 单调队列的维护
        for len(q) > 0 && nums[q[len(q) - 1]] <= val{
            // 那么，之前在这个队列里面的数是不配在 val这个数前面的，我们要把前面这个数给删掉
            q = q[: len(q) - 1]
        }
        // 把元素下标添加进来
        q = append(q, i)
        
        // 出队
        // 出队的条件是滑动窗口长度过大，队首元素应该出队
        // 也就是说，队首元素已经不是它在的所有窗口的队首了
        // 就像是 1 1 5 3 4,可以看到，假设长度k为2的话，那么窗口为 [1 1],[1 5] [5 3],这个时候,5就会被移走，也就是当前索引比队首元素下标大k的时候，队首会被移走
        if i - q[0] >= k{
            q = q[1:]
        }
        
        // 添加答案
        //什么时候添加答案呢，可以看到
        // [1  3  -1] -3  5  3  6  7       3
 		// 1 [3  -1  -3] 5  3  6  7       3
 		// 1  3 [-1  -3  5] 3  6  7       5
        
        // 实际上，这里的长度是k,那么在i小于k-1(下标要-1)时，实际上是没有答案的，不构成滑动窗口的长度
        // 然后，在构成滑动窗口后，每次都会添加进来一个最大值，一直添加到 len(nums) - k
        if i >= k - 1{
            // 添加队首元素
            ans = append(ans, nums[q[0]])
        }
        
    }
    return ans
    
}
```

