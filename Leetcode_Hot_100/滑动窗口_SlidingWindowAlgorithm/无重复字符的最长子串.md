# 无重复字符的最长字串

## 描述

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长** 
>
> **子串**
>
>  的长度。
>
> 
>
>  
>
> **示例 1:**
>
> ```
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> ```

意思就是说，在一个字串内不可以有重复出现的字符，比如说`abcabcbb`这个字串中，不重复的字串可以是`abc`这个字串。

## 思路

描述要求是字串中会包含所有的ASCII字符，总共是127个ASCII字符，所以我们只需要使用一个额外的数组来做哈希表即可。

- 先从最开始扫描这个字串，每扫描到一个字符，那么就把这个字符加入到哈希表里面去。
- 当扫描到重复的字符时，把这个重复的字符从哈希表里面删除掉，然后再把它加入哈希表里面，不删直接加的话会重复添加。
- 此时，一定是当前左指针的字符发生重复，此时移动左指针



## 代码实现

```go
func lengthOfLongestSubstring(s string) int {
    // 先声明一下答案和哈希表
    ans := 0
    cnt := [128]bool{}
    // 声明左指针
    l := 0
    for r, c := range s{
        // 如果当前字符存在的话，那么我们就删除
        // 删除的时候，一定是删除的左指针
        for cnt[c]{
            cnt[s[l]] = false
            l++
        }
        // 不存在的话，把这个字符加进去
        cnt[c] = true
        // 更新答案
        ans = max(ans, r - l + 1)
    }
    return ans
}
```

