# 轮转数组

## 描述

> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,4,5,6,7], k = 3
> 输出: [5,6,7,1,2,3,4]
> 解释:
> 向右轮转 1 步: [7,1,2,3,4,5,6]
> 向右轮转 2 步: [6,7,1,2,3,4,5]
> 向右轮转 3 步: [5,6,7,1,2,3,4]
> ```
>
> **示例 2:**
>
> ```
> 输入：nums = [-1,-100,3,99], k = 2
> 输出：[3,99,-1,-100]
> 解释: 
> 向右轮转 1 步: [99,-1,-100,3]
> 向右轮转 2 步: [3,99,-1,-100]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-231 <= nums[i] <= 231 - 1`
> - `0 <= k <= 105`

## 思路

- 利用额外的数组
- 环形数组
- 原地反转

### 利用额外的数组

1. 题目的意思就是去向后推元素即可，相当于是一个环形数组，这起始是一个基本的操作，需要我们用到`%`来帮助。

   ```go
   func rotate(nums []int, k int)  {
       n := len(nums)
       ans := make([]int, n)
       for i := 0; i < n; i++{
           ans[(i + k) % n] = nums[i]
       }
       copy(nums, ans)
   }
   ```

   这个思路还是比较容易实现的。

2. 原地反转
   这里举个例子，方便理解，假设我们这里存在一个数组

   ```txt
   k = 3
   
   1 2 3 4 5 6 7
   ```

   也就是说反转后的数组是

   ```txt
   5 6 7   1 2 3 4
   ```

   这个思路挺神奇的，就是去实现三次反转，注意到(注意力惊人)，原数组反转后是

   ```txt
   7 6 5  |  4 3 2 1
   ```

   与我们的目标答案做对比，可以发现，前[0,k]个元素是被反转的，剩下的 [k, n - 1]也是被反转的，所以我们可以实现三次反转。

   代码如下：

   ```go 
   func rotate(nums []int, k int)  {
       n := len(nums)
       k = k % n
       r(nums, 0, n - 1)
       r(nums, 0, k - 1)
       r(nums, k, n - 1) 
   }
   
   func r(nums []int, i int, j int){
       for i <= j{
           nums[i], nums[j] = nums[j], nums[i]
           i++
           j--
       }
   }
   ```

   对此，在go里面一个比较容易实现`swap`的方法就是去像`python`一样去实现两边交换