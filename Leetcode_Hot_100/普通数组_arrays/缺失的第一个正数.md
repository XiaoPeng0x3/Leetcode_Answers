# 缺失的第一个正数

## 描述

> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
>
> 请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,0]
> 输出：3
> 解释：范围 [1,2] 中的数字都在数组中。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,4,-1,1]
> 输出：2
> 解释：1 在数组中，但 2 没有。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [7,8,9,11,12]
> 输出：1
> 解释：最小的正数 1 没有出现。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-231 <= nums[i] <= 231 - 1`



## 思路

这个思路真的很好，也确实很难想到。主要的思路就是去手动构建一个哈希表。在原数组的基础上构建出来一个哈希表，因为要找的是第一个缺失的正数，那么我们就按照大小序来构建一个哈希表。如果按照大小序来排的话，那么，出现的顺序一定就是`[1,2,3,4,6,7]`这样的顺序，那么我们就可以一次遍历来找到那个缺失的正数(这个例子里面是5)。



## 代码实现

- 只关心 `1 ~ n+1`的所有正数
- 把所有的数交换到正确的位置上去
- 从头开始一一对照，直到找到不符合条件的数

```go
func firstMissingPositive(nums []int) int {
    // 好像是有一些思路了
    // 我们要做的就是原地进行哈希表的交换，把nums[i]交换到nums[nums[i] - 1]的地方去
    // 也就是说，在一个数组里面，把这个数组的所有元素全部安排好，然后再看下标哪里不对应

    n := len(nums)
    for i := 0; i < n; i++{
        // 我们所交换的数必须都是1~n+1范围内的
        for nums[i] <= n && 1 <= nums[i] && nums[nums[i] - 1] != nums[i]{
            // 已经在正确位置的数不必交换
            nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]
        }
    }

    for i := 0; i < n; i++{
        if i + 1 != nums[i]{
            return i + 1
        }
    }
    return n + 1
}
```

如果一个数都出现了，比如在数组[1,2,3]里面，那么缺失的第一个正数就是4,也就是`len(nums)+1`。反之，则是返回`i+1`。