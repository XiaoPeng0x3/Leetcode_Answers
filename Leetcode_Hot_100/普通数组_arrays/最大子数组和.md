# 最大子数组和

## 描述

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 
>
> **子数组**
>
> 是数组中的一个连续部分。
>
> 
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [5,4,-1,7,8]
> 输出：23
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`
>
>  
>
> **进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

## 思路

暴力的解法还是很容易想到和写出来的，这里就不再过多叙述。主要有两种更加巧妙的方法，就是**贪心**和**分之递归法**。ps:这道题目起始在最初学数据结构的时候就遇到过，那个时候还认为这个题目非常难，其实不然。

### 贪心

既然我们要找寻最大的子数组和，那么，我们可以假设几种极端情况：

- 数组所有的元素都是正的
- 数组所有的元素都是负的

对此来说，如果所有的元素全部都是正的，那么，最大的子数组和就是整个数组的和，这时没有什么问题的。如果所有的元素全部都是负数，那么，子数组和的最大值就是数组里面最大的那个负数。

那么，我们想要尽可能的使我们的子数组元素和大，**对于小于0的那一部分子数组**实际上只会拖累我们的后腿，所以，我们实际上不需要那部分小于0的数组，只需要考虑哪一部分是大于0的即可。因此就可以写出第一份贪心代码

```go
func maxSubArray(nums []int) int {
    // 这道题目还是有印象的，一种做法是贪心做法，就是去维护一个sum,如果sum < 0 的话，肯定不是我们的最大值
    sum := 0
    ans := -100010
    for _, val := range nums{
        sum += val
        ans = max(ans, sum)
        //小于0不去计入数组和
        if sum < 0{
            sum = 0
        }
    }
    return ans
}
```

这里还是去判断了负数的情况。



## 分治

分治的思路是：给定一个数组，要算最大的子数组和，我们可以计算三部分，比如把区间分为两部分，一部分是`l`,一部分是`r`,我们可以计算一个左区间的最大值，然后再计算一个右区间的最大值，最后再计算一个跨越左右区间的最大值，然后比较一下这三部分哪个最大，最后返回最大值。

```go
func maxSubArray(nums []int) int {
    n := len(nums)
    return maxSum(nums, 0, n - 1)
}

func maxSum(nums []int, s int, e int) int{
    if s >= e{
        return nums[s]
    }
    m := (s + e) / 2
    leftMax := maxSum(nums,s, m)
    rightMax := maxSum(nums, m + 1, e)
    // 跨越区间的最大值
    leftSum, rightSum := 0, 0
    lSum, rSum := -100086, -100086 //跨越区间
    for i := m; i >= s; i--{
        leftSum += nums[i]
        lSum = max(leftSum, lSum) //记录连续左区间最大值
    }
    // 同理计算rightSUm
    for j := m + 1; j <= e; j++{
        rightSum += nums[j]
        rSum = max(rSum, rightSum) //记录连续右区间最大值
    }
    // 再计算一下跨越区间的最大值
    allSum := lSum + rSum
    return max(max(leftMax, rightMax), allSum)
    
}
```



