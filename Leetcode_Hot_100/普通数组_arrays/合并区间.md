# 合并区间



## 描述

> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> ```
>
> **示例 2：**
>
> ```
> 输入：intervals = [[1,4],[4,5]]
> 输出：[[1,5]]
> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
> ```

## 思路

题目的意思就是去看一看有没有重叠的部分，比如说[1,4],[2,6],在这两个区间内部就有重叠的部分，对于重叠的部分，我们需要直接进行合并，上面这两个数组合并后的结果就是[1,6]。

- 先是进行排序，这样我们就可以根据左端点的值来进行重叠的判断。
- 排好序后，我们就可以根据左端点来进行比较是否重叠，我们可以把情况分为三类：
  - 第一种情况，假设有两个数组，`[x1,y1],[x2,y2]`,根据第一步，我们已经排好序了，所以，此时一定有`x2 >= x1`,那么，只需比较`x2`和`y1`的大小即可。加入`x2 > y1`,那么这两个部分一定是不沾边的，所以不需要我们进行合并。
  - 第二种情况就是`x2` < =`y1`,那么，就需要我们进行合并，但是此时又引出来另一个问题，就是，`x2`所在的区间是真子集还是只是有包含的部分。如果是真子集的话，那么，我们的区间起始是不需要合并的，比如`[1,5]和[2,3]`这两个区间。后者就是前者的真子集
  - 另外就是需要我们合并的地方，比如`[1,5]和[2,6]、[3,7]`这三个区间，可以看到，最后的合并结果是`[1,7]`。这样就引起了我们的思考，在这种情况下，也就是`x2 <= y1`并且`y1 <= y2`的情况下，合并后的区间的**右端点一定是区间的一个最大值**，此时我们只需要把最大值记录下来，最后构建成我们区间的右端点即可。



## 代码实现

这里的区间实际上就两种情况：

- 两个区间可以合成一个的
- 两个区间无法合成的

```go
func merge(intervals [][]int) [][]int {
    // 先排序
    sort.Slice(intervals, func(i, j int)bool{
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    n := len(intervals)
    //先把区间的端点值记录下来
    start, end := intervals[0][0], intervals[0][1]
    for i := 1; i < n; i++{
        //如果intervals[1][0]（x2 < y1）的情况，不需要合并，直接添加结果即可
        if intervals[i][0] > end{
            ans = append(ans,[]int{start, end})
            //直接向后迭代，看一看后面的区间的情况
            start = intervals[i][0]
            end = intervals[i][1]
        } else {
            // 需要合并的情况，即 x2 <= y1,那么，左端点一定是x1,而右端点就不知道是谁了。第一个左端点一定是最小的，如果说有n个区间可以合并([x1,y1]、[x2,y2]、[x3,y3]....[xn,yn]都是可以合并为一个的)，那么合并后的区间的左端点一定是x1,而合并后的右端点一定是max(y1,y2,y3,.....yn)
            end = max(end, intervals[i][1])
            
        }
    }
    // 最后把这几个区间加进来
    ans = append(ans, []int{start, end})
    return ans
    
}
```

