# 除自身以外数组的乘积

## 题目描述

> 给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。
>
> 题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。
>
> 请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,4]
> 输出: [24,12,8,6]
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [-1,1,0,-3,3]
> 输出: [0,0,9,0,0]
> ```



实际上，题目的意思就是做乘法，然后返回即可。



## 思路

### 额外的数组

实际上，对于数组里面的一个数来说，我们**可以把这个数在数组里面位置，把数组划分为左右两个部分：L和R**，那么对于这两部分来说，计算一个数的乘积，那么就可以转化为**L[i] * R[i]**即可

```txt
这是一个数组
1 2 3 4 5 6 7

假设我们要计算这个数组除了3以外的乘积，那么，就等同于
1 2 (3) 4 5 6 7

计算这样的一个乘积
[1,2] (3) [4,5,6,7]

那么L[2]数组就是[1,2]的乘积,R[2]数组就是[4,5,6,7],于是，我们可以直接计算L[2] * R[2]这样的乘积即可
```

#### 代码实现

```go
 func productExceptSelf(nums []int) []int {
     n := len(nums)
     // 先准备好数组
     L := make([]int, n)
     R := make([]int, n)
     ans := make([]int, n)
     // 最左边那个数是没有乘积的，所以我们在收集的时候，最左边那个就是1
     L[0] = 1
     //同理，左边那个数也是
     R[n - 1] = 1
     //此时就可以开始计算了
     for i := 1; i < n; i++{
         L[i] = L[i - 1] * nums[i - 1]
     }
     //此时也可以计算出来左边的数
     //最后那个数的右区间也是1，所以不用从最后一个数开始，直接从倒数第二个数开始
     for j := n - 2; j >= 0; j--{
         R[j] = R[j + 1] * nums[j + 1]
     }
     //此时就把所有的收集好了，然后我们就直接乘积即可
     
     for i := 0; i < n; i++{
         ans[i] = L[i] * R[i]
     }
     return ans
 }
```

其实有点像前缀和，重要的还是打板题目的思路



### 不使用额外的数组

实际上我们只需要想办法去进行构造即可，怎么构造答案即可。左边还是正常去进行计算，在右边的时候直接进行构造。

```go
 func productExceptSelf(nums []int) []int {
     //左边还是一样的
     n := len(nums)
     // 先准备好数组
     ans := make([]int, n)
     // 最左边那个数是没有乘积的，所以我们在收集的时候，最左边那个就是1
     ans[0] = 1
     //此时就可以开始计算了
     for i := 1; i < n; i++{
         ans[i] = ans[i - 1] * nums[i - 1]
     }
     // 计算好左边之后，右边的乘积直接在答案上面进行构造
     rnum := 1 // 辅助变量
     for j := n - 1; j >= 0; j--{
         ans[j] = ans[j] * rnum //最右边的数是左边的乘积乘以rnum
         rnum *= nums[j]
     }
     return ans
 }
```



